MFP -- music for programmers 

MFP is an environment for visually composing computer programs, with
an emphasis on music and real-time audio synthesis and analysis.  It's
very much inspired by Miller Puckette's Pure Data (pd) and MAX/MSP,
with a bit of LabView and TouchOSC for good measure.  

MFP is in its early development phases.  Large pieces of core functionality
are not implemented yet, including: complete support for extensions,
multiple selection, cut/copy/paste, undo, hosting of plugins, JACK MIDI,
i18n, audio file reading, etc etc etc.

What IS there is the basic program window and patch editor, enough 
message and DSP processors to build some demo patches, a model for how
a mostly-keyboard-controlled GUI app will work, and the infrastructure
of the 3 separate processes (main, GUI, and DSP) that work together to
make MFP happen. 

Prerequisites: a bunch of dependencies need to be installed for this
to work.  I use debian sid (unstable) but I don't depend on bleeding
edge anything beyond that.  I think that 'apt-get install' on the below 
will pull in any necessary dependencies. 

    Basics: 
        python (python2.7 on sid, 2.6 should work too) 
        gcc (to build DSP extensions)
        python-dev (for Python.h)
        python-setuptools 
        python-nose 
        python-virtualenv
        python-simplejson 
        pkg-config  
        
    Python packages from PYPI (not in Debian):
        posix_ipc 

    Clutter-based GUI: 
        libgtk-3-dev
        libclutter-1.0-dev 
        python-gi (GObject Introspection for Python)
        gir1.2-clutter-1.0 (clutter bindings for GI)
        gir1.2-gtkclutter-1.0 (clutter-GTK bindings for GI)
        gir1.2-cogl-1.0 (COGL bindings for GI)
        gir1.2-coglpango-1.0 (COGL Pango bindings for GI)

    JACK/ALSA/etc: 
        libjack0
        libjack0-dev
        libasound2
        libasound2-dev
        liblo7 (OSC library, python bindings in lib/)
        liblo-dev 

Building: I suggest using 'virtualenv' to build in a sandbox.   The
packages in "lib" are required for MIDI and OSC functionality and I
couldn't find them for easy_install.

From the top level (where this file is located): 

    $ virtualenv --python=python2.7 --system-site-packages virtual
    $ . virtual/bin/activate 
    
If you don't have posix_ipc on your system: 

    $ pip install posix_ipc 

Install libs and main program:

    $ for dir in testext pluginfo lib/alsaseq-0.4.1 lib/pyliblo-0.9.1 ;
      do (cd $dir ; python ./setup.py install) 
      done 
    $ python ./setup.py install 

Then, run the unit tests:

    $ python /usr/bin/nosetests -v mfp 
    $ python /usr/bin/nosetests -v --with-testext --exe build 

The second line uses a custom nose plugin (testext) to run unit tests
in a compiled C extension called "mfpdsp" used by MFP.  I'm not aware
of another tool to automatically discover and run plain C tests in
plain C libraries.  

If all that works: 
    $ mfp 

The very, very basic tutorial: 

Try:  
    mfp -h for a command line arguments summary.  
    mfp --help-builtins lists the name and tooltip of every builtin object. 

Follow these steps to create a helloworld patch using just the keyboard.
You do need a pointer to activate it. 

You type	What happens
----------- ------------------
a			Autoplace mode.  A + appears where the next object will go
m			Create message (literal data)
"hello world" RET	Put the string "hello, world" in the message 
c			Connect mode (will connect selected object to something)
a			Autoplace mode again
p			Create a processor
print RET		Make it a [print] processor
RET			Make the connection

Now click on the message box to send the "hello, world" string.  

Below the patch editing area, in the "Log" tab, you will see the message 
appear.

At any time, the "Keybindings" tab to the left of the patch editing area
will show you all the active key bindings.  Bindings nearer the top are 
chosen first, so if there are 2 listings for RET for instance the top one will
be used.

Demo patches: There are a few demo patches in doc/ which are really all the
documentation there is right now.  Since there's no support for load paths
yet, you need to copy these into the root level of the source tree to run
them. 

Run the demo patch by putting the file name on the command line, i.e. 

    $ mfp hello_world.mfp

hello_world.mfp:  The classic 

biquad_designer.mfp:  Not complete!  But at least partly working.  Click
the "calculate" button to compute biquad coefficients and audition them
with a noise input source (I run this into JAAA to check my calculations).
PGDN to shift to the Graphs layer with pole/zero and analytical frequency
response.  You need to add doc/ to the patch search path for this to load 
(it uses the "quadratic.mfp" patch).  From the directory holding this 
README: 

    $ mfp -p doc doc/biquad_designer.mfp

oscope.mfp: Simple demo of the signal<-->control level bridge provided by
numpy and the buffer~ object.  A very basic oscilloscope. 

looper.mfp: A simple 4-channel loop sampler inspired by the Akai Headrush,
also built around a [buffer~].  Connect an audio input via JACK, select a
channel to record with the toggle, click PLAY then REC.  Unclick REC at the
end of your loop and PLAY will continue to loop over your recording.
Change channel, repeat until satisfied.  Arming and disarming "play_enable"
controls the mix of each loop.

Saving files: There's no UI for saving yet, but there is a key mapping.
C-s (control S) will prompt for a file to save in.  There's no checking for
overwrite, and the file is saved in the process working directory. 


Reporting problems: For now, I will be using the GitHub hosted issue
tracker and wiki. 

Enjoy! 

Bill Gribble <grib@billgribble.com>
